<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trading Chakra — Charts + Indicators</title>

  <!-- Lightweight Charts CDN (stable) -->
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>

  <style>
  :root{
    --bg: #0b1220;
    --panel: #0f2233;
    --muted: #94a3b8;
    --accent: #38bdf8;
    --up: #22c55e;
    --down: #ef4444;
    --surface: #0f1724;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial,sans-serif;color:#e6eef8}
  #app{display:grid;grid-template-columns:300px 1fr;height:100vh}
  .sidebar{padding:18px;background:#071523;box-sizing:border-box;border-right:1px solid rgba(255,255,255,0.03);overflow:auto}
  .sidebar h1{margin:0 0 12px 0;color:var(--accent);font-size:34px}
  #search{width:100%;padding:12px;border-radius:8px;border:none;outline:none;margin-bottom:14px;background:#081021;color:#e6eef8;box-sizing:border-box}
  #watchlist{list-style:none;padding:0;margin:0}
  #watchlist li{background:#122635;margin:8px 0;padding:18px;border-radius:8px;cursor:pointer;color:#e6eef8;text-transform:uppercase;letter-spacing:0.8px;transition:background .15s}
  #watchlist li:hover{background:#183349}
  #watchlist li.active{background:#254a63}
  .add-stock { display:flex; gap:8px; margin-top:10px; align-items:center }
  .add-stock input{flex:1;padding:10px;border-radius:8px;border:none;background:#06101a;color:#cfe6ff}
  .btn {background:var(--accent); border:none;color:#003047;padding:10px 14px;border-radius:8px;cursor:pointer}
  .btn.secondary {background:transparent;border:1px solid rgba(255,255,255,0.06);color:#bcd3ea}
  .panel {margin-top:18px;background:#071824;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .panel h3{margin:0 0 10px 0;color:#bfe7ff}
  .field{margin-bottom:10px}
  .field label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  .field input[type="text"], .field input[type="number"]{width:100%;padding:8px;border-radius:6px;border:none;background:#07161d;color:#dfefff}
  .timeframes{display:flex;gap:8px;align-items:center}
  .tf-btn{background:#0a1a25;border:none;color:#bcd3ea;padding:8px 12px;border-radius:8px;cursor:pointer}
  .tf-btn.active{background:var(--accent);color:#002b38}
  .chart-area{display:flex;flex-direction:column;background:var(--surface);height:100%}
  #toolbar{height:56px;display:flex;align-items:center;padding:0 18px;border-bottom:1px solid rgba(255,255,255,0.03);gap:12px}
  #symbol-title{font-weight:700;color:#e6eef8;font-size:18px}
  #chart-container{flex:1;min-height:0;position:relative}
  #spinner{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);padding:12px 18px;border-radius:8px;font-weight:700;display:none}
  #error{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#2b0f0f;color:#ffd2d2;padding:12px 16px;border-radius:8px;max-width:80%;text-align:center;display:none}
  .legend { margin-left:auto; color:var(--muted); font-size:13px }
  .preset-list{margin-top:8px}
  .preset-item{padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);margin:6px 0;display:flex;justify-content:space-between;align-items:center}
  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .small{font-size:13px;padding:8px;border-radius:6px}
  @media (max-width:900px){ #app{grid-template-columns:1fr} .sidebar{height:200px;overflow:auto} }
  </style>
</head>
<body>
  <div id="app">
    <aside class="sidebar">
      <h1>Watchlist</h1>
      <input id="search" placeholder="Search stock..." />

      <ul id="watchlist"></ul>

      <div class="add-stock">
        <input id="add-symbol" placeholder="Add symbol, e.g. RELIANCE.NS" />
        <button id="add-btn" class="btn">Add</button>
      </div>

      <div class="panel">
        <h3>Presets</h3>
        <div class="field">
          <input id="preset-name" type="text" placeholder="Give preset a name" />
        </div>
        <div style="display:flex;gap:8px">
          <button id="save-preset" class="btn">Save Preset</button>
          <button id="export-preset" class="btn secondary">Export</button>
        </div>
        <div class="preset-list" id="preset-list"></div>
      </div>

      <div class="panel" style="margin-top:12px">
        <h3>Indicator Controls</h3>
        <div style="margin-bottom:8px"><label><input id="toggle-reliable" type="checkbox" checked/> Reliable S/R</label></div>
        <div class="controls-grid">
          <div class="field">
            <label>Pivot Left</label>
            <input id="pivot-left" type="number" value="15" />
          </div>
          <div class="field">
            <label>Pivot Right</label>
            <input id="pivot-right" type="number" value="15" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div style="margin-bottom:8px"><label><input id="toggle-lux" type="checkbox" checked/> LuxAlgo S/R</label></div>
        <div class="controls-grid">
          <div class="field">
            <label>Lux len1</label>
            <input id="lux-len1" type="number" value="50" />
          </div>
          <div class="field">
            <label>Lux mlt1</label>
            <input id="lux-mlt1" type="number" value="2" step="0.1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div style="margin-bottom:8px"><label><input id="toggle-island" type="checkbox" checked/> Island Reversal</label></div>
        <div class="field">
          <label>Island gap threshold (fraction of ATR)</label>
          <input id="island-gap-mult" type="number" value="1.5" step="0.1" />
        </div>
      </div>
    </aside>

    <main class="chart-area">
      <div id="toolbar">
        <div id="symbol-title">Loading...</div>

        <div id="timeframes" class="timeframes" style="margin-left:12px">
          <button class="tf-btn" data-tf="1m">1m</button>
          <button class="tf-btn" data-tf="5m">5m</button>
          <button class="tf-btn" data-tf="15m">15m</button>
          <button class="tf-btn" data-tf="30m">30m</button>
          <button class="tf-btn" data-tf="60m">60m</button>
          <button class="tf-btn active" data-tf="1D">1D</button>
          <button class="tf-btn" data-tf="1W">1W</button>
          <button class="tf-btn" data-tf="1M">1M</button>
        </div>

        <div class="legend">
          <span id="live-price">—</span>
        </div>
      </div>

      <div id="chart-container">
        <div id="spinner">Loading...</div>
        <div id="error">Error</div>
        <div id="chart" style="width:100%;height:calc(100vh - 56px)"></div>
        <div id="volume" style="height:110px"></div>
      </div>
    </main>
  </div>

<script>
/* ============================
   Full app JS — single-file
   ============================ */

/* ---------------------------
   CONFIG - adjust if needed
   --------------------------- */
const WORKER_URL = "https://black-tree-2e32.sriviadithi.workers.dev/?symbol="; // <<-- your worker - keep as is
const LIVE_POLL_MS = 5000; // poll for last price (ms)

/* ---------------------------
   DOM refs
   --------------------------- */
const watchlistEl = document.getElementById('watchlist');
const addSymbolInput = document.getElementById('add-symbol');
const addBtn = document.getElementById('add-btn');
const spinner = document.getElementById('spinner');
const errorBox = document.getElementById('error');
const symbolTitle = document.getElementById('symbol-title');
const livePriceEl = document.getElementById('live-price');
const tfButtons = document.querySelectorAll('.tf-btn');

const presetNameInput = document.getElementById('preset-name');
const savePresetBtn = document.getElementById('save-preset');
const exportPresetBtn = document.getElementById('export-preset');
const presetListEl = document.getElementById('preset-list');

const toggleReliable = document.getElementById('toggle-reliable');
const pivotLeftInput = document.getElementById('pivot-left');
const pivotRightInput = document.getElementById('pivot-right');

const toggleLux = document.getElementById('toggle-lux');
const luxLen1 = document.getElementById('lux-len1');
const luxMlt1 = document.getElementById('lux-mlt1');

const toggleIsland = document.getElementById('toggle-island');
const islandGapMult = document.getElementById('island-gap-mult');

/* ---------------------------
   State
   --------------------------- */
let watchlist = loadWatchlist();
let currentSymbol = watchlist.length ? watchlist[0] : null;
let currentTf = '1D';
let chart = null, candleSeries = null, volumeSeries = null;
let priceLine = null;
let indicatorLines = []; // keep references to created price lines / markers so we can clear
let liveTimer = null;

/* ---------------------------
   Utility helpers
   --------------------------- */
function saveWatchlist() { localStorage.setItem('tc_watchlist', JSON.stringify(watchlist)); }
function loadWatchlist() { try { return JSON.parse(localStorage.getItem('tc_watchlist')) || ['RELIANCE.NS','TCS.NS','INFY.NS','HDFCBANK.NS','ICICIBANK.NS']; } catch(e){ return ['RELIANCE.NS']; } }
function showSpinner(){ spinner.style.display='block'; }
function hideSpinner(){ spinner.style.display='none'; }
function showError(msg){ errorBox.innerText = msg; errorBox.style.display='block'; }
function hideError(){ errorBox.style.display='none'; }

/* convert worker time to chart time (lightweight-charts expects unix seconds) */
function toChartTime(t){
  // if t looks like ms ( > 1e12 ), convert to seconds
  if (t > 1e12) return Math.floor(t/1000);
  return t;
}

/* create and render watchlist UI */
function renderWatchlist(){
  watchlistEl.innerHTML='';
  watchlist.forEach(sym => {
    const li = document.createElement('li');
    li.innerText = sym;
    li.dataset.symbol = sym;
    li.addEventListener('click', () => {
      loadChart(sym);
    });
    watchlistEl.appendChild(li);
  });
}

/* mark active */
function markActiveSymbol(sym){
  document.querySelectorAll('#watchlist li').forEach(li => li.classList.toggle('active', li.dataset.symbol === sym));
}

/* Add symbol */
addBtn.addEventListener('click', () => {
  const s = addSymbolInput.value.trim();
  if(!s) return;
  if (!watchlist.includes(s)){
    watchlist.unshift(s.toUpperCase());
    saveWatchlist();
    renderWatchlist();
  }
  addSymbolInput.value='';
  loadChart(s.toUpperCase());
});

/* timeframes */
tfButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    tfButtons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentTf = btn.dataset.tf;
    if(currentSymbol) loadChart(currentSymbol);
  });
});

/* ---------------------------
   Chart creation
   --------------------------- */
function createChartIfNeeded(){
  if (chart) return;
  const chartDiv = document.getElementById('chart');
  chart = LightweightCharts.createChart(chartDiv, {
    layout: { backgroundColor: "#ffffff", textColor: "#000000" },
    width: chartDiv.clientWidth,
    height: chartDiv.clientHeight - 0,
    rightPriceScale: { borderColor: '#d0d7df' },
    timeScale: { borderColor: '#d0d7df' },
    grid: { vertLines: { color: '#e7ebef' }, horzLines: { color: '#e7ebef' } }
  });
  candleSeries = chart.addCandlestickSeries({
    upColor: "#26a69a", downColor: "#ef5350", borderVisible: true, wickVisible:true
  });
  volumeSeries = chart.addHistogramSeries({
    priceFormat: { type: 'volume' }, color: '#4c78ff', priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 }
  });
  window.addEventListener('resize', () => {
    chart.applyOptions({
      width: chartDiv.clientWidth,
      height: chartDiv.clientHeight
    });
  });
}

/* ---------------------------
   Fetch data from worker
   - expects an array of { time, open, high, low, close, volume }
   - time should be unix seconds (or ms - converted)
   --------------------------- */
async function fetchOHLC(symbol, tf){
  // adapt tf param to your worker parameter format; we'll add &tf=...
  const url = WORKER_URL + encodeURIComponent(symbol) + '&tf=' + encodeURIComponent(tf);
  const resp = await fetch(url);
  if (!resp.ok) throw new Error('HTTP ' + resp.status);
  const data = await resp.json();
  if (!Array.isArray(data)) throw new Error('Invalid data format');
  // map to chart format
  const mapped = data.map(row => ({
    time: toChartTime(row.time),
    open: +row.open,
    high: +row.high,
    low: +row.low,
    close: +row.close,
    volume: row.volume !== undefined ? +row.volume : 0
  }));
  return mapped;
}

/* update live price (polling) */
async function pollLivePrice(symbol){
  try {
    const url = WORKER_URL + encodeURIComponent(symbol) + '&tf=' + encodeURIComponent('1m') + '&latest=1';
    const resp = await fetch(url);
    if (!resp.ok) return;
    const data = await resp.json();
    if (!Array.isArray(data) || data.length === 0) return;
    const last = data[data.length-1];
    const price = Number(last.close);
    livePriceEl.innerText = price ? price.toFixed(2) : '—';
    // optionally, update a single price line on chart
    if (candleSeries && priceLine){
      priceLine.applyOptions({ price: price });
    } else if (candleSeries && !priceLine){
      priceLine = candleSeries.createPriceLine({price: price, color: '#38bdf8', lineWidth:1, lineStyle:0, axisLabelVisible:true, title: 'Last'});
    }
  } catch(e){
    // fail silently
    console.warn('live poll error', e);
  }
}

/* ---------------------------
   Indicator helpers (approx conversion of Pine ideas)
   - Reliable S/R: pivot-based horizontal lines
   - Lux-style: sma-based lines + multiplier (upper/lower)
   - Island reversal: detect isolated gap + small range, draw box
   --------------------------- */

function sma(arr, len){
  if (len <= 0) return [];
  const out = [];
  for(let i=0;i<arr.length;i++){
    if (i < len-1) { out.push(null); continue; }
    let sum = 0;
    for(let j=0;j<len;j++) sum += arr[i-j].close;
    out.push(sum / len);
  }
  return out;
}

function detectPivots(data, left=15, right=15){
  // returns arrays of pivot highs/lows as values (time, value)
  const highs = [], lows = [];
  for(let i=left;i<data.length-right;i++){
    let isHigh = true, isLow = true;
    for(let j=1;j<=left;j++){ if (data[i].high <= data[i-j].high) isHigh=false; if (data[i].low >= data[i-j].low) isLow=false; }
    for(let j=1;j<=right;j++){ if (data[i].high <= data[i+j].high) isHigh=false; if (data[i].low >= data[i+j].low) isLow=false; }
    if (isHigh) highs.push({i:i, time:data[i].time, value:data[i].high});
    if (isLow) lows.push({i:i, time:data[i].time, value:data[i].low});
  }
  return {highs, lows};
}

function computeLuxSR(data, len, mlt){
  // simple Bollinger upper/lower using sma & stddev
  const res = [];
  for(let i=0;i<data.length;i++){
    if (i < len-1) { res.push(null); continue; }
    let sum=0;
    for(let j=0;j<len;j++) sum += data[i-j].close;
    const avg = sum/len;
    let v=0;
    for(let j=0;j<len;j++){ const d = data[i-j].close - avg; v += d*d; }
    const sd = Math.sqrt(v/len);
    res.push({upper: avg + sd*mlt, lower: avg - sd*mlt, mid: avg});
  }
  return res;
}

function detectIslandReversals(data, gapMult=1.5){
  // very simplified:
  // if open today-gap compared to prev close > ATR*gapMult and it remains an isolated gap (i.e., next few bars do not overlap)
  const out = [];
  // compute ATR(14)
  const atrLen = 14;
  const trs = [];
  for(let i=1;i<data.length;i++){
    const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i-1].close), Math.abs(data[i].low - data[i-1].close));
    trs.push(tr);
  }
  function avg(arr){ if(!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
  const atr = avg(trs.slice(-atrLen));
  for(let i=1;i<data.length-1;i++){
    const prevClose = data[i-1].close;
    const open = data[i].open;
    const gap = Math.abs(open - prevClose);
    if (gap > (atr * gapMult)){
      // check isolation: following bar does not fill gap immediately
      const next = data[i+1];
      if (next && ((open > prevClose && next.low > prevClose) || (open < prevClose && next.high < prevClose))){
        // mark box covering from high to low across i..i+1.. maybe a few bars
        let top = Math.max(data[i].high, next.high);
        let bottom = Math.min(data[i].low, next.low);
        out.push({startTime:data[i].time, endTime:data[i+1].time, top, bottom});
      }
    }
  }
  return out;
}

/* clear previously created indicator lines / price lines */
function clearIndicatorLines(){
  // price lines created on candleSeries via createPriceLine
  if (!candleSeries) return;
  indicatorLines.forEach(item => {
    try{
      if (item.priceLine) candleSeries.removePriceLine(item.priceLine);
      if (item.volSeries) volumeSeries.removePriceLine && volumeSeries.removePriceLine(item.priceLine); // safe
      // markers removal: use setMarkers([])
      if (item.markerSeries) item.markerSeries.setMarkers([]);
    }catch(e){}
  });
  indicatorLines = [];
}

/* build and draw indicators on chart */
function drawIndicators(data){
  clearIndicatorLines();
  if (!data || !data.length) return;

  // Reliable S/R (pivot horizontals)
  if (toggleReliable.checked){
    const left = parseInt(pivotLeftInput.value) || 15;
    const right = parseInt(pivotRightInput.value) || 15;
    const piv = detectPivots(data, left, right);
    // pick top N pivots and draw unique horizontal lines
    const combined = [...piv.highs.map(h=>({v:h.value,t:h.time,typ:'r'})), ...piv.lows.map(l=>({v:l.value,t:l.time,typ:'s'}))];
    combined.sort((a,b)=>Math.abs(b.t - data[data.length-1].time) - Math.abs(a.t - data[data.length-1].time));
    const uniq = [];
    combined.forEach(c => {
      if (!uniq.some(u => Math.abs(u.v - c.v) < (Math.abs(c.v)*0.002 + 0.0001))) uniq.push(c);
    });
    // only draw first 10
    uniq.slice(0,12).forEach((u, idx) => {
      const pl = candleSeries.createPriceLine({
        price: u.v,
        color: u.typ === 'r' ? '#ff6b6b' : '#14b8a6',
        lineWidth: u.typ === 'r' ? 2 : 1,
        lineStyle: 1,
        axisLabelVisible: true,
        title: (u.typ==='r'?'R':'S') + (idx+1)
      });
      indicatorLines.push({ priceLine: pl, meta: u });
    });
  }

  // Lux-style S/R (SMA + upper/lower)
  if (toggleLux.checked){
    const len = Math.max(5, parseInt(luxLen1.value) || 50);
    const mlt = parseFloat(luxMlt1.value) || 2;
    const lux = computeLuxSR(data, len, mlt);
    // pick last valid entry
    for (let i = lux.length-1; i>=0; i--){
      if (lux[i]) {
        const last = lux[i];
        // draw lines
        const midLine = candleSeries.createPriceLine({ price: last.mid, color:'#2b82ff', lineWidth:1, lineStyle:2, title:'Lux mid' });
        const upLine = candleSeries.createPriceLine({ price: last.upper, color:'#6ef0a8', lineWidth:1, lineStyle:2, title:'Lux up' });
        const lowLine = candleSeries.createPriceLine({ price: last.lower, color:'#f09ea8', lineWidth:1, lineStyle:2, title:'Lux low' });
        indicatorLines.push({ priceLine: midLine, meta: {type:'lux'} });
        indicatorLines.push({ priceLine: upLine, meta: {type:'lux'} });
        indicatorLines.push({ priceLine: lowLine, meta: {type:'lux'} });
        break;
      }
    }
  }

  // Island Reversal boxes (simple)
  if (toggleIsland.checked){
    const gapMult = parseFloat(islandGapMult.value) || 1.5;
    const islands = detectIslandReversals(data, gapMult);
    // We'll draw vertical lines as markers (LightweightCharts lacks rectangle boxes API)
    // Use a tiny helper series for markers
    const markers = [];
    islands.forEach((isl, idx) => {
      markers.push({ time: toChartTime(isl.startTime), position: 'belowBar', color: '#000', shape: 'circle', text: 'IR' });
      // draw price-lines for top & bottom
      const topL = candleSeries.createPriceLine({ price: isl.top, color:'#ffd966', lineWidth:1, lineStyle:1, title:'IR top' });
      const botL = candleSeries.createPriceLine({ price: isl.bottom, color:'#ffd966', lineWidth:1, lineStyle:1, title:'IR bottom' });
      indicatorLines.push({ priceLine: topL, meta:{type:'island'}});
      indicatorLines.push({ priceLine: botL, meta:{type:'island'}});
    });
    // set markers (single set)
    candleSeries.setMarkers(markers);
    indicatorLines.push({ markerSeries: candleSeries, meta:{type:'islands_markers'} });
  }
}

/* ---------------------------
   Main: loadChart
   --------------------------- */
async function loadChart(symbol){
  currentSymbol = symbol;
  markActiveSymbol(symbol);
  symbolTitle.innerText = symbol;
  showSpinner(); hideError();
  createChartIfNeeded();
  // Clear existing data
  try {
    const data = await fetchOHLC(symbol, currentTf);
    if (!data || !data.length) { showError('No data returned'); hideSpinner(); return; }
    // set candle and volume data
    const candleData = data.map(d => ({ time: toChartTime(d.time), open: d.open, high: d.high, low: d.low, close: d.close }));
    const volumeData = data.map(d => ({ time: toChartTime(d.time), value: d.volume || 0, color: (d.close>=d.open)?'#22c55e':'#ef4444' }));
    candleSeries.setData(candleData);
    volumeSeries.setData(volumeData);
    chart.timeScale().fitContent();
    // draw indicators
    drawIndicators(data);
    // price line initial
    const last = data[data.length-1];
    if (last){
      if (priceLine) candleSeries.removePriceLine(priceLine);
      priceLine = candleSeries.createPriceLine({ price: last.close, color:'#38bdf8', lineWidth:1, axisLabelVisible:true, title:'Last' });
      livePriceEl.innerText = Number(last.close).toFixed(2);
    }
    // start live poll
    if (liveTimer) clearInterval(liveTimer);
    liveTimer = setInterval(()=>pollLivePrice(symbol), LIVE_POLL_MS);
  } catch (e){
    console.error(e);
    showError('Failed to load chart: '+ (e.message || e));
  } finally {
    hideSpinner();
  }
}

/* ---------------------------
   Presets: save/load/export/import
   --------------------------- */
function getCurrentPreset(){
  return {
    name: presetNameInput.value || ('preset_' + Date.now()),
    reliable: { enabled: toggleReliable.checked, pivotLeft: parseInt(pivotLeftInput.value)||15, pivotRight: parseInt(pivotRightInput.value)||15 },
    lux: { enabled: toggleLux.checked, len1: parseInt(luxLen1.value)||50, mlt1: parseFloat(luxMlt1.value)||2 },
    island: { enabled: toggleIsland.checked, gapMult: parseFloat(islandGapMult.value)||1.5 },
    // you can add more items to save indicator state
  };
}

function savePreset(){
  const p = getCurrentPreset();
  const stored = JSON.parse(localStorage.getItem('tc_presets')||'[]');
  stored.push(p);
  localStorage.setItem('tc_presets', JSON.stringify(stored));
  renderPresetList();
  presetNameInput.value = '';
}

function renderPresetList(){
  presetListEl.innerHTML = '';
  const stored = JSON.parse(localStorage.getItem('tc_presets')||'[]');
  stored.forEach((p, idx) => {
    const div = document.createElement('div');
    div.className='preset-item';
    div.innerHTML = `<div>${p.name}</div><div style="display:flex;gap:6px">
      <button class="btn secondary load-btn" data-idx="${idx}">Load</button>
      <button class="btn secondary del-btn" data-idx="${idx}">Delete</button>
    </div>`;
    presetListEl.appendChild(div);
  });
  document.querySelectorAll('.load-btn').forEach(b=>b.addEventListener('click', (ev)=>{
    const idx = parseInt(ev.currentTarget.dataset.idx);
    const stored = JSON.parse(localStorage.getItem('tc_presets')||'[]');
    const p = stored[idx];
    if (!p) return;
    // apply preset
    toggleReliable.checked = !!p.reliable.enabled;
    pivotLeftInput.value = p.reliable.pivotLeft;
    pivotRightInput.value = p.reliable.pivotRight;
    toggleLux.checked = !!p.lux.enabled;
    luxLen1.value = p.lux.len1;
    luxMlt1.value = p.lux.mlt1;
    toggleIsland.checked = !!p.island.enabled;
    islandGapMult.value = p.island.gapMult;
    // redraw
    if (currentSymbol) loadChart(currentSymbol);
  }));
  document.querySelectorAll('.del-btn').forEach(b=>b.addEventListener('click', (ev)=>{
    const idx = parseInt(ev.currentTarget.dataset.idx);
    const stored = JSON.parse(localStorage.getItem('tc_presets')||'[]');
    stored.splice(idx,1);
    localStorage.setItem('tc_presets', JSON.stringify(stored));
    renderPresetList();
  }));
}

exportPresetBtn.addEventListener('click', ()=>{
  const stored = JSON.parse(localStorage.getItem('tc_presets')||'[]');
  const blob = new Blob([JSON.stringify(stored, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'tc_presets.json'; a.click();
  URL.revokeObjectURL(url);
});

savePresetBtn.addEventListener('click', savePreset);

/* import via file drop? simple prompt */
exportPresetBtn.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const json = prompt('Paste preset JSON here to import:');
  if (!json) return;
  try{
    const parsed = JSON.parse(json);
    localStorage.setItem('tc_presets', JSON.stringify(parsed));
    renderPresetList();
    alert('Imported presets');
  }catch(err){ alert('Invalid JSON'); }
});

/* ---------------------------
   init app
   --------------------------- */
function init(){
  renderWatchlist();
  renderPresetList();
  // attach search filter
  document.getElementById('search').addEventListener('input', (e)=>{
    const q = e.target.value.trim().toLowerCase();
    document.querySelectorAll('#watchlist li').forEach(li=>{
      li.style.display = (!q || li.innerText.toLowerCase().includes(q)) ? '' : 'none';
    });
  });
  // setup initial chart
  const initial = currentSymbol || (watchlist.length?watchlist[0]:null);
  if (initial) loadChart(initial);

  // when indicator controls change -> redraw on current data
  [toggleReliable, pivotLeftInput, pivotRightInput, toggleLux, luxLen1, luxMlt1, toggleIsland, islandGapMult].forEach(el=>{
    el.addEventListener('change', ()=>{ if (currentSymbol) loadChart(currentSymbol); });
  });

  // also allow pressing Enter to add symbol
  addSymbolInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter') addBtn.click(); });

  // initial mark active
  markActiveSymbol(initial);
}

init();

/* ---------------------------
   Clean up on unload
   --------------------------- */
window.addEventListener('beforeunload', ()=>{ if (liveTimer) clearInterval(liveTimer); });

</script>
</body>
</html>
