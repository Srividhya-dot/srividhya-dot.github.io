<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Compact Chart + Watchlist (Option A)</title>

<!-- Lightweight Charts (explicit version known to expose addCandlestickSeries) -->
<script src="https://unpkg.com/lightweight-charts@3.9.0/dist/lightweight-charts.standalone.production.js"></script>

<style>
:root{
  --bg:#071122; --panel:#0b2230; --muted:#94a3b8; --accent:#38bdf8;
  --up:#22c55e; --down:#ef4444; --surface:#0f1724;
}
*{box-sizing:border-box;font-family:Inter, Arial, sans-serif}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef8}
.app{display:flex;height:100vh;overflow:hidden}

/* Left watchlist */
.side{
  width:320px;background:linear-gradient(180deg,#071a27 0,#071a27 100%);
  padding:18px;border-right:1px solid rgba(255,255,255,0.03);overflow:auto;
}
.side h2{margin:0 0 12px;color:var(--accent);font-size:30px}
.search{width:100%;background:#071826;color:#cfe6ff;padding:10px;margin-bottom:12px;border-radius:8px;border:none}
.watchlist{list-style:none;padding:0;margin:0}
.watchlist li{
  background:#122b36;margin:10px 0;padding:16px;border-radius:8px;cursor:pointer;
  text-transform:uppercase;letter-spacing:0.6px;color:#e6eef8;font-weight:600
}
.watchlist li.active{background:#244f63}
.add-row{display:flex;gap:8px;margin-top:12px}
.add-row input{flex:1;background:#071026;padding:10px;color:#cfe6ff;border-radius:8px;border:none}
.add-row button{background:var(--accent);color:#01222b;padding:10px 14px;border-radius:8px;border:none;cursor:pointer}

/* top ribbon (controls) */
.ribbon{
  position:relative;display:flex;align-items:center;gap:14px;padding:14px 18px;
  background:linear-gradient(90deg, rgba(0,0,0,0.25), rgba(0,0,0,0.05));
  border-bottom:1px solid rgba(255,255,255,0.03);
}
.ribbon .group{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:13px}
.ribbon input[type="number"]{width:64px;padding:8px;border-radius:8px;border:none;background:#071827;color:#cfe6ff}
.ribbon .tf-btn{background:rgba(255,255,255,0.03);border-radius:8px;padding:8px 12px;border:none;color:#cfe6ff;cursor:pointer}
.ribbon .tf-btn.active{background:var(--accent);color:#01222b}

/* main area */
.main{flex:1;display:flex;flex-direction:column;min-width:0}
.toolbar{display:flex;align-items:center;padding:8px 18px}
.symbolTitle{font-weight:700;font-size:20px;margin-right:18px}
.chart-wrap{flex:1;display:flex;min-height:0;position:relative;padding:12px}
.chart-box{flex:1;background:var(--surface);padding:12px;display:flex;flex-direction:column;min-height:0;border-radius:6px}
#chart{flex:1;min-height:0;border-radius:6px}

/* small feedback boxes */
.spinner, .error{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.7);padding:12px 18px;border-radius:10px;font-weight:700
}
.error{background:#2b0f0f;color:#ffd2d2;display:none}
.hidden{display:none}

/* responsive */
@media (max-width:1000px){
  .side{display:none}
}
</style>
</head>
<body>

<div class="app">
  <!-- LEFT WATCHLIST -->
  <aside class="side" id="leftPanel">
    <h2>Watchlist</h2>
    <input id="searchInput" class="search" placeholder="Search symbol..." />
    <ul id="watchlist" class="watchlist"></ul>

    <div class="add-row" style="margin-top:8px">
      <input id="addSymbol" placeholder="Add symbol (e.g., RELIANCE.NS)" />
      <button id="addBtn">Add</button>
    </div>

    <div style="margin-top:20px;color:var(--muted);font-size:13px">
      <div style="margin-bottom:6px">Presets (save current indicator numbers)</div>
      <div style="display:flex;gap:8px;">
        <input id="presetName" placeholder="Preset name" style="flex:1;padding:8px;border-radius:8px;border:none;background:#071827;color:#cfe6ff"/>
        <button id="savePreset" style="background:var(--accent);color:#01222b;padding:8px;border-radius:8px;border:none">Save</button>
      </div>
      <div id="presetList" style="margin-top:8px;color:var(--muted)">Saved presets:</div>
    </div>
  </aside>

  <!-- MAIN: top ribbon + chart -->
  <main class="main">
    <div class="ribbon" id="ribbon">
      <div class="group">
        <label style="color:#cfe6ff;font-weight:700;margin-right:6px">Reliable S/R</label>
        <input id="pivotLeft" type="number" min="1" value="15" />
        <input id="pivotRight" type="number" min="1" value="15" />
        <label style="margin-left:6px"><input type="checkbox" id="toggleReliable" checked/> Show</label>
      </div>

      <div class="group">
        <label style="color:#cfe6ff;font-weight:700;margin-right:6px">LuxAlgo</label>
        <input id="luxLen1" type="number" min="2" value="50" />
        <input id="luxMlt1" type="number" min="0.1" step="0.1" value="2" />
        <label style="margin-left:6px"><input type="checkbox" id="toggleLux" checked/> Show</label>
      </div>

      <div class="group">
        <label style="color:#cfe6ff;font-weight:700;margin-right:6px">Island</label>
        <input id="islandTrend" type="number" min="2" value="10" />
        <label style="margin-left:6px"><input type="checkbox" id="toggleIsland" checked/> Show</label>
      </div>

      <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
        <button class="tf-btn" data-tf="1m">1m</button>
        <button class="tf-btn" data-tf="5m">5m</button>
        <button class="tf-btn active" data-tf="15m">15m</button>
        <button class="tf-btn" data-tf="30m">30m</button>
        <button class="tf-btn" data-tf="60m">60m</button>
        <button class="tf-btn" data-tf="1D">1D</button>
        <button class="tf-btn" data-tf="1W">1W</button>
        <button class="tf-btn" data-tf="1M">1M</button>
      </div>
    </div>

    <div class="toolbar">
      <div class="symbolTitle" id="symbolTitle">Loading...</div>
    </div>

    <div class="chart-wrap">
      <div class="chart-box">
        <div id="chart"></div>
        <div id="spinner" class="spinner">Loading...</div>
        <div id="error" class="error"></div>
      </div>
    </div>
  </main>
</div>

<script>
/*
  Compact UI (Option A) single-file app.
  IMPORTANT:
   - Replace WORKER_URL with your worker endpoint that proxies Yahoo (must add CORS headers).
   - This expects the worker to accept ?symbol=...&interval=...&range=...
   - The worker you posted earlier (worker.js with corsHeaders) is perfect.
*/

/* ---------------- CONFIG ---------------- */
const WORKER_URL = "https://your-worker.example.workers.dev/?symbol="; // <<-- REPLACE with your worker endpoint
const DEFAULT_SYMBOLS = ["RELIANCE.NS","TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS"];

/* DOM */
const watchlistEl = document.getElementById('watchlist');
const symbolTitle = document.getElementById('symbolTitle');
const chartDiv = document.getElementById('chart');
const spinner = document.getElementById('spinner');
const errorBox = document.getElementById('error');

const addSymbolInput = document.getElementById('addSymbol');
const addBtn = document.getElementById('addBtn');
const searchInput = document.getElementById('searchInput');

const tfButtons = Array.from(document.querySelectorAll('.tf-btn'));

const toggleReliable = document.getElementById('toggleReliable');
const toggleLux = document.getElementById('toggleLux');
const toggleIsland = document.getElementById('toggleIsland');

const pivotLeft = document.getElementById('pivotLeft');
const pivotRight = document.getElementById('pivotRight');

const luxLen1 = document.getElementById('luxLen1');
const luxMlt1 = document.getElementById('luxMlt1');

const islandTrend = document.getElementById('islandTrend');

const presetName = document.getElementById('presetName');
const savePresetBtn = document.getElementById('savePreset');
const presetList = document.getElementById('presetList');

let watchSymbols = JSON.parse(localStorage.getItem('watchSymbols')) || DEFAULT_SYMBOLS.slice();
let presets = JSON.parse(localStorage.getItem('chartPresets')) || {};

/* ---------------- CHART SETUP ---------------- */
let chart = null;
let candleSeries = null;
let volumeSeries = null;
let srObjects = []; // store created price lines
let lastSymbol = null;
let activeTF = '15m';
let pollTimer = null; // single declaration, reused

function createChart(){
  if(chart) return;
  chart = LightweightCharts.createChart(chartDiv, {
    layout: { backgroundColor: "#0f1724", textColor: "#d1d4dc" },
    rightPriceScale: { borderColor: "#485c7b" },
    timeScale: { borderColor: "#485c7b", timeVisible: true, secondsVisible: false },
    grid: { vertLines: {color:'#253248'}, horzLines:{color:'#253248'} },
  });

  candleSeries = chart.addCandlestickSeries({
    upColor: "#22c55e", downColor: "#ef4444", borderVisible:true, wickVisible:true
  });

  volumeSeries = chart.addHistogramSeries({
    priceFormat: { type: 'volume' },
    priceScaleId: '',
    scaleMargins: { top: 0.8, bottom: 0 },
  });
}

/* ---------------- UI helpers ---------------- */
function showSpinner(){ spinner.classList.remove('hidden'); spinner.style.display='block'; }
function hideSpinner(){ spinner.classList.add('hidden'); spinner.style.display='none'; }
function showError(msg){ errorBox.style.display='block'; errorBox.textContent = msg; }
function hideError(){ errorBox.style.display='none'; }

/* watchlist rendering */
function renderWatchlist(){
  watchlistEl.innerHTML = '';
  for(let sym of watchSymbols){
    const li = document.createElement('li');
    li.textContent = sym;
    li.dataset.symbol = sym;
    li.addEventListener('click', ()=> loadChart(sym));
    watchlistEl.appendChild(li);
  }
  attachActiveToList(lastSymbol);
}
function attachActiveToList(sym){
  Array.from(watchlistEl.children).forEach(li=>{
    li.classList.toggle('active', li.dataset.symbol === sym);
  });
}

/* add symbol */
addBtn.addEventListener('click', ()=>{
  const v = (addSymbolInput.value || '').trim().toUpperCase();
  if(!v) return;
  if(!watchSymbols.includes(v)){ watchSymbols.unshift(v); localStorage.setItem('watchSymbols', JSON.stringify(watchSymbols)); renderWatchlist(); }
  addSymbolInput.value='';
  loadChart(v);
});
searchInput.addEventListener('input', e=>{
  const q = e.target.value.trim().toLowerCase();
  Array.from(watchlistEl.children).forEach(li=>{
    li.style.display = q && !li.textContent.toLowerCase().includes(q) ? 'none' : '';
  });
});

/* timeframes */
tfButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    tfButtons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    activeTF = btn.dataset.tf;
    if(lastSymbol) loadChart(lastSymbol);
  });
});

/* presets */
function renderPresets(){
  presetList.innerHTML = 'Saved presets:';
  const keys = Object.keys(presets);
  if(!keys.length) { presetList.innerHTML += '<div style="color:var(--muted);margin-top:6px">no saved presets</div>'; return; }
  for(const k of keys){
    const div = document.createElement('div');
    div.style.marginTop='6px';
    div.innerHTML = `<strong style="margin-right:8px">${k}</strong>
      <button data-name="${k}" class="loadPreset" style="margin-right:6px">Load</button>
      <button data-name="${k}" class="delPreset" style="background:transparent;color:var(--muted)">Delete</button>`;
    presetList.appendChild(div);
  }
  Array.from(document.getElementsByClassName('loadPreset')).forEach(b=>{
    b.addEventListener('click', ()=> {
      const name = b.dataset.name; applyPreset(presets[name]);
    });
  });
  Array.from(document.getElementsByClassName('delPreset')).forEach(b=>{
    b.addEventListener('click', ()=> {
      const name = b.dataset.name; delete presets[name]; localStorage.setItem('chartPresets', JSON.stringify(presets)); renderPresets();
    });
  });
}
savePresetBtn.addEventListener('click', ()=>{
  const name = (presetName.value||'').trim();
  if(!name) { alert('Give preset a name'); return; }
  const preset = {
    pivotLeft: pivotLeft.valueAsNumber,
    pivotRight: pivotRight.valueAsNumber,
    luxLen1: luxLen1.valueAsNumber,
    luxMlt1: luxMlt1.valueAsNumber,
    islandTrend: islandTrend.valueAsNumber,
    toggles: { reliable: toggleReliable.checked, lux: toggleLux.checked, island: toggleIsland.checked }
  };
  presets[name] = preset;
  localStorage.setItem('chartPresets', JSON.stringify(presets));
  renderPresets();
  presetName.value = '';
});
renderWatchlist();
renderPresets();

/* ---------------- FETCH / DATA ----------------
   fetchOHLC expects worker to return Yahoo JSON structure (chart.result[0]...)
*/
async function fetchOHLC(symbol, range='1y', granularity='1d'){
  if(!WORKER_URL || WORKER_URL.includes("your-worker")) {
    console.warn("WORKER_URL is placeholder. Replace with your worker endpoint.");
  }
  // Worker expects query like: ?symbol=...&range=...&interval=...
  const url = WORKER_URL + encodeURIComponent(symbol) + `&range=${encodeURIComponent(range)}&interval=${encodeURIComponent(granularity)}`;
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const json = await res.json();

    // Yahoo-like structure
    if(json && json.chart && json.chart.result && json.chart.result[0]){
      const r = json.chart.result[0];
      const timestamps = r.timestamp || [];
      const quote = r.indicators?.quote?.[0];
      if(Array.isArray(timestamps) && quote){
        const out = [];
        for(let i=0;i<timestamps.length;i++){
          const t = timestamps[i];
          const o = quote.open?.[i];
          const h = quote.high?.[i];
          const l = quote.low?.[i];
          const c = quote.close?.[i];
          const v = quote.volume?.[i] ?? 0;
          if(o==null||h==null||l==null||c==null) continue;
          out.push({time: t, open:o, high:h, low:l, close:c, volume:v});
        }
        return out;
      }
    }

    // fallback if worker returns array
    if(Array.isArray(json)) return json.map(normalizeBar);

    // wrapper {data: [...]}
    if(json && json.data && Array.isArray(json.data)) return json.data.map(normalizeBar);

    console.warn('Unrecognized response format from worker', json);
    return [];
  }catch(err){
    console.error('fetchOHLC error', err);
    throw err;
  }
}

function normalizeBar(b){
  if(!b) return null;
  let t = b.time || b.timestamp || b.date || (Array.isArray(b) ? b[0] : null);
  if(!t) return null;
  if(t > 1e12) t = Math.floor(t/1000);
  t = Math.floor(t);
  return { time: t, open:+b.open, high:+b.high, low:+b.low, close:+b.close, volume:+(b.volume||0) };
}

/* TF seconds */
const tfSeconds = { '1m':60, '5m':300, '15m':900, '30m':1800, '60m':3600, '1D':86400, '1W':86400*7, '1M':86400*30 };

/* convert source (ascending) to target TF */
function convertToTF(sourceBars, sourceSec, targetTF){
  const targetSec = tfSeconds[targetTF] || 86400;
  if(sourceSec === targetSec) return sourceBars.slice();
  if(targetSec >= sourceSec){
    const groups = new Map();
    for(const b of sourceBars){
      const key = Math.floor(b.time / targetSec);
      if(!groups.has(key)) groups.set(key, []);
      groups.get(key).push(b);
    }
    const out = [];
    for(const [k, arr] of groups){
      const o = arr[0].open;
      const h = Math.max(...arr.map(x=>x.high));
      const l = Math.min(...arr.map(x=>x.low));
      const c = arr[arr.length-1].close;
      const v = arr.reduce((s,x)=>s+x.volume,0);
      out.push({time: k * targetSec, open:o, high:h, low:l, close:c, volume:v});
    }
    out.sort((a,b)=>a.time-b.time);
    return out;
  }
  // synthesize intraday from daily
  const out = [];
  for(const day of sourceBars){
    const parts = Math.max(1, Math.floor(86400 / targetSec));
    for(let p=0;p<parts;p++){
      const t = day.time + p * targetSec;
      const open = day.open;
      const close = day.close;
      const o = open + (close - open) * (p / parts);
      const c = open + (close - open) * ((p + 1) / parts);
      const h = Math.max(o, c, day.high * (0.995 + 0.01*Math.random()));
      const l = Math.min(o, c, day.low * (1 - 0.01*Math.random()));
      const v = Math.round(day.volume / parts);
      out.push({time: t, open:o, high:h, low:l, close:c, volume:v});
    }
  }
  out.sort((a,b)=>a.time-b.time);
  return out;
}

/* ---------------- INDICATORS ---------------- */
/* Reliable pivot-based horizontal levels */
function computeReliableSR(bars, left=15, right=15){
  const levels = [];
  for(let i=left; i<bars.length-right; i++){
    const center = bars[i];
    let isPH = true, isPL = true;
    for(let j=i-left; j<=i+right; j++){
      if(j===i) continue;
      if(bars[j].high >= center.high) isPH = false;
      if(bars[j].low <= center.low) isPL = false;
      if(!isPH && !isPL) break;
    }
    if(isPH) levels.push({price:center.high, label:'R', color:'#ef4444', width:2, strength:1});
    if(isPL) levels.push({price:center.low, label:'S', color:'#22c55e', width:2, strength:1});
  }
  // dedupe / merge
  const merged = [];
  levels.sort((a,b)=>b.price-a.price);
  for(const L of levels){
    const found = merged.find(m=>Math.abs(m.price - L.price) < (L.price*0.0015));
    if(found){
      found.count = (found.count||1)+1;
      found.price = (found.price + L.price)/2;
    } else merged.push({...L, count:1});
  }
  merged.sort((a,b)=>b.count - a.count);
  return merged.slice(0, 40);
}

/* LuxAlgo simplified (SMA + bands) */
function computeLuxSR(bars, len=50, mlt=2){
  if(bars.length < len) return [];
  const closes = bars.map(b=>b.close);
  const smaArr = [];
  let sum=0;
  for(let i=0;i<closes.length;i++){
    sum += closes[i];
    if(i>=len) sum -= closes[i-len];
    if(i>=len-1) smaArr.push({time:bars[i].time, value: sum/len});
    else smaArr.push({time:bars[i].time, value: null});
  }
  const lastIdx = smaArr.length-1;
  const mean = smaArr[lastIdx].value;
  const window = closes.slice(lastIdx - len + 1, lastIdx + 1);
  const variance = window.reduce((s,x)=>s+Math.pow(x-mean,2),0)/len;
  const std = Math.sqrt(variance);
  const upper = mean + mlt*std;
  const lower = mean - mlt*std;
  return [
    {price: upper, label:'Lux Upper', color:'#ffd166', width:1},
    {price: mean, label:'Lux SMA', color:'#60a5fa', width:2},
    {price: lower, label:'Lux Lower', color:'#7c3aed', width:1}
  ];
}

/* Island Reversal detection (simplified) */
function computeIslandReversals(bars, trendLen=10, volFilter=true){
  const reversals = [];
  for(let i=1;i<bars.length-1;i++){
    const prev = bars[i-1], cur = bars[i], next = bars[i+1];
    // bullish island: gap up then gap down
    if(cur.low > prev.high && next.high < cur.low){
      // volume filter
      let volAvg = 0;
      let count = 0;
      for(let j=Math.max(0,i-trendLen); j<i; j++){ volAvg += bars[j].volume; count++; }
      volAvg = count ? volAvg / count : 0;
      if(volFilter && cur.volume < volAvg) continue;
      reversals.push({startTime: cur.time, endTime: next.time, top: cur.high, bottom: cur.low, bullish:true});
    }
    // bearish island
    if(cur.high < prev.low && next.low > cur.high){
      let volAvg = 0, count=0;
      for(let j=Math.max(0,i-trendLen); j<i; j++){ volAvg += bars[j].volume; count++; }
      volAvg = count ? volAvg / count : 0;
      if(volFilter && cur.volume < volAvg) continue;
      reversals.push({startTime: cur.time, endTime: next.time, top: cur.high, bottom: cur.low, bullish:false});
    }
  }
  return reversals;
}

/* ---------------- DRAWING ---------------- */
function clearIndicators(){
  for(const obj of srObjects){
    try{ candleSeries.removePriceLine(obj); }catch(e){}
  }
  srObjects = [];
}

function drawLines(levels){
  for(const L of levels){
    try{
      const pl = candleSeries.createPriceLine({
        price: L.price,
        color: L.color || '#999',
        lineWidth: L.width || 1,
        lineStyle: LightweightCharts.LineStyle.Solid,
        axisLabelVisible: true,
        title: L.label || ''
      });
      srObjects.push(pl);
    }catch(e){
      console.warn('priceLine error', e);
    }
  }
}

function drawIslands(islands){
  for(const it of islands){
    const color = it.bullish ? 'rgba(8,153,129,0.12)' : 'rgba(242,54,69,0.12)';
    const topLine = candleSeries.createPriceLine({price:it.top, color:color, lineWidth:2, title: it.bullish ? 'Island Top' : 'Island Top'});
    const botLine = candleSeries.createPriceLine({price:it.bottom, color:color, lineWidth:2, title: it.bullish ? 'Island Bottom' : 'Island Bottom'});
    srObjects.push(topLine, botLine);
  }
}

/* ---------------- MAIN LOADER ---------------- */
async function loadChart(symbol){
  if(!symbol) return;
  lastSymbol = symbol;
  attachActiveToList(symbol);
  createChart();
  showSpinner();
  hideError();
  symbolTitle.innerText = symbol;

  // fetch data - ask worker for daily (1d) source; for intraday we will convert if needed
  try{
    // If user picked an intraday timeframe, try to fetch intraday from worker as that gives better granularity
    const targetSec = tfSeconds[activeTF] || 86400;
    // determine request interval for worker: if intraday requested, ask worker for 1m if available, else 1d
    const requestInterval = (targetSec < 86400) ? '1m' : '1d';
    const srcBars = await fetchOHLC(symbol, '1y', requestInterval);
    hideSpinner();
    if(!srcBars || srcBars.length===0){
      showError('No data returned for ' + symbol);
      return;
    }

    srcBars.sort((a,b)=>a.time - b.time);
    // detect source seconds (best-effort)
    let srcSec = 86400;
    if(srcBars.length >= 2) srcSec = Math.max(60, Math.round((srcBars[1].time - srcBars[0].time)));
    const bars = convertToTF(srcBars, srcSec, activeTF);

    const lcData = bars.map(b=>({
      time: b.time,
      open: Number(b.open),
      high: Number(b.high),
      low: Number(b.low),
      close: Number(b.close)
    }));

    try{
      candleSeries.setData(lcData);
      chart.timeScale().fitContent();
    }catch(err){
      console.error('chart setData error', err);
      showError('Chart rendering error â€” data may be malformed.');
      return;
    }

    // volume
    try{
      const vData = bars.map(b=>({time:b.time, value:b.volume, color: b.close >= b.open ? '#22c55e' : '#ef4444'}));
      volumeSeries.setData(vData);
    }catch(e){/*ignore*/}

    // indicators
    clearIndicators();
    if(toggleReliable.checked){
      const levels = computeReliableSR(bars, pivotLeft.valueAsNumber || 15, pivotRight.valueAsNumber || 15);
      drawLines(levels.map(l=>({price:l.price, label:l.label, color:l.color, width:l.width})));
    }
    if(toggleLux.checked){
      const lux = computeLuxSR(bars, luxLen1.valueAsNumber || 50, luxMlt1.valueAsNumber || 2);
      drawLines(lux);
    }
    if(toggleIsland.checked){
      const islands = computeIslandReversals(bars, islandTrend.valueAsNumber || 10, true);
      drawIslands(islands);
    }

    // live polling
    setupLivePolling(symbol, srcSec);
  }catch(err){
    hideSpinner();
    showError('Data fetch failed: ' + (err.message || err));
  }
}

/* ------------- Live Polling ------------- */
function isTradingNow(){
  const d = new Date();
  const hours = d.getHours();
  const mins = d.getMinutes();
  // local browser time assumed IST for simplicity; adjust if you need timezone conversion
  return (hours > 9 && hours < 16) || (hours === 9 && mins >= 0) || (hours === 15 && mins <= 30);
}

async function fetchLatestQuote(symbol){
  const out = await fetchOHLC(symbol,'5d','1d');
  if(!out || out.length===0) return null;
  return out[out.length-1];
}

function setupLivePolling(symbol, srcSec){
  const interval = Math.max(2, 5);
  if(pollTimer) { clearInterval(pollTimer); pollTimer = null; }
  pollTimer = setInterval(async ()=>{
    try{
      if(!isTradingNow()) return;
      // simple approach: refresh full chart - network cost is acceptable for usability
      await loadChart(symbol);
    }catch(err){
      console.warn('poll error', err);
    }
  }, interval*1000);
}

/* apply event handlers for top ribbon controls */
document.getElementById('pivotLeft').addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
document.getElementById('pivotRight').addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
document.getElementById('luxLen1').addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
document.getElementById('luxMlt1').addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
document.getElementById('islandTrend').addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
toggleReliable.addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
toggleLux.addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));
toggleIsland.addEventListener('change', ()=> lastSymbol && loadChart(lastSymbol));

/* initial default load */
if(watchSymbols.length>0) {
  renderWatchlist();
  loadChart(watchSymbols[0]);
}

/* cleanup */
window.addEventListener('beforeunload', ()=> { if(pollTimer) clearInterval(pollTimer); });

</script>
</body>
</html>
